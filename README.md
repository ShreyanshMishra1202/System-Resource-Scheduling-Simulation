# System Resource Scheduling Simulation

## Project Overview

This repository implements a system-level, time-driven simulation for priority-based resource scheduling. The simulation models a discrete-event system where requests compete for limited resources under operational constraints. The primary goal is to validate scheduling correctness, analyze resource utilization patterns, and understand system behavior under various load conditions.

**Phase 1 Focus:** This initial phase establishes the foundational architecture, including correct system modeling, state management, and non-preemptive scheduling logic. Code implementation follows the design documented here.

**Target Use Cases:**
- Validation of scheduling algorithms under controlled scenarios
- Analysis of resource contention and utilization metrics
- Study of system behavior under varying priority distributions
- Foundation for advanced preemptive scheduling extensions

---

## System Model

The simulation models the following entities:

### Resources
- **Definition:** A finite set of identical, serially-reusable resources (e.g., computation units, network channels).
- **Capacity:** Fixed integer count; all resources are functionally equivalent.
- **Availability:** Resources transition between IDLE and BUSY states based on allocation.

### Requests
- **Arrival:** Requests arrive at discrete time steps, each characterized by:
  - `priority`: Integer value (higher = more urgent)
  - `duration`: Integer time units required for execution
  - `arrival_time`: Simulation time when request enters the system
- **Lifecycle:** A request progresses through: PENDING → RUNNING → COMPLETED

### Simulation Time
- **Model:** Discrete time steps (t = 0, 1, 2, ...)
- **Advancement:** Time advances in unit increments; all events within a time step are processed atomically.
- **Termination:** Simulation ends when all requests complete or a predefined time limit is reached.

---

## Scheduling Policy

### Non-Preemptive Priority Scheduling

**Policy Description:**
- Requests are scheduled strictly by priority (highest first).
- Once a request begins execution, it runs to completion without interruption.
- Among requests with equal priority, FIFO ordering is applied (earliest arrival first).

**Decision Points:**
- At each time step, after completing any finishing requests:
  1. Release resources from completed requests
  2. Select the highest-priority pending request
  3. Allocate resources if available; otherwise, the request waits

**Scheduling Invariant:**
- At any time step, no pending request with priority `P` waits if resources are available and no request with priority ≥ `P` is running or pending ahead in queue.

---

## System States

The simulation tracks two primary system-level states:

### IDLE State
- **Condition:** All resources are unallocated; no requests are running.
- **Characteristics:**
  - Pending queue may be non-empty (requests waiting for future time steps)
  - No active resource consumption
  - Transitions to BUSY when a request is scheduled

### BUSY State
- **Condition:** At least one resource is allocated to a running request.
- **Characteristics:**
  - One or more requests are executing
  - Resources are in use; some may still be idle if capacity allows
  - Transitions to IDLE when all running requests complete simultaneously

**State Transition Triggers:**
- IDLE → BUSY: First request allocated after idle period
- BUSY → IDLE: Last running request completes

---

## Assumptions

The simulation operates under the following assumptions:

1. **Resource Homogeneity:** All resources are identical; any request can execute on any available resource.
2. **Deterministic Duration:** Request execution times are known a priori and deterministic.
3. **No Failures:** Resources and requests do not fail; all executions complete successfully.
4. **No Arrivals During Execution:** Request arrival times are predetermined; no dynamic arrivals generated by running requests.
5. **Atomic Operations:** All scheduling decisions and state transitions within a time step are atomic.
6. **Single Resource per Request:** Each request requires exactly one resource unit (no multi-resource requests).
7. **Non-Negative Priorities:** Priority values are non-negative integers (0 is valid).

---

## Invariants

The following invariants are maintained throughout simulation execution:

1. **Resource Conservation:**
   ```
   running_requests ≤ total_resources
   ```

2. **Priority Ordering:**
   ```
   For any running request R1 and pending request R2:
   priority(R1) ≥ priority(R2) OR resources fully allocated
   ```

3. **Progress:**
   ```
   If resources exist and requests are pending:
   At least one request must be scheduled or running at each time step
   (unless all pending requests have future arrival times)
   ```

4. **Time Monotonicity:**
   ```
   current_time is non-decreasing
   arrival_time(R) ≤ start_time(R) ≤ completion_time(R)
   ```

5. **State Consistency:**
   ```
   System is IDLE ⟺ running_requests = 0
   ```

---

## Known Limitations

### Phase 1 Constraints

1. **No Preemption:** Higher-priority requests cannot interrupt running lower-priority requests. This may lead to priority inversion scenarios.

2. **Fixed Request Set:** All requests and their characteristics must be known before simulation starts. No support for runtime request generation.

3. **Single Resource Type:** Only one class of interchangeable resources is modeled. Heterogeneous resource types are not supported.

4. **No Resource Contention Modeling:** Advanced effects such as cache thrashing, memory contention, or network congestion are not modeled.

5. **Deterministic Model:** No stochastic elements; repeated runs with identical inputs produce identical results.

6. **No Deadline Constraints:** Requests have priorities but no explicit deadlines or real-time constraints.

---

## Future Extensions

### Phase 2: Preemptive Scheduling
- Implement priority-based preemption with context-switch overhead
- Support for dynamic priority adjustments (e.g., priority aging)
- Analysis of preemption frequency and its impact on throughput

### Phase 3: Advanced Resource Models
- Multi-resource requests (e.g., CPU + memory)
- Heterogeneous resource types with compatibility constraints
- Resource pools with hierarchical allocation policies

### Phase 4: Dynamic Workloads
- Poisson or burst arrival patterns
- Request generation based on running system state
- Adaptive priority assignment algorithms

### Phase 5: Real-Time Constraints
- Deadline-aware scheduling (EDF, LLF)
- Admission control and overload handling
- Schedulability analysis tools

### Phase 6: Performance Optimization
- Efficient data structures for large-scale simulations
- Parallel simulation execution
- Incremental result computation and checkpointing

---

## Development Status

**Current Phase:** Phase 1 - Foundation  
**Status:** Design complete; implementation in progress  
**Language/Tools:** TBD (Python/C++/other based on performance requirements)

---

## License

TBD

---

## Contact

For questions or contributions, please open an issue in this repository.
